<?php
/**
 * @file
 * Main module file for the Render Cache caching system.
 */

// -----------------------------------------------------------------------
// Core Hooks

/**
 * Implements hook_flush_caches().
 */
function render_cache_flush_caches() {
  return array('cache_render');
}

// -----------------------------------------------------------------------
// Contrib Hooks

/**
 * Implements hook_ctools_plugin_type().
 */
function render_cache_ctools_plugin_type() {
  $items['controller'] = array(
    'cache' => FALSE,
    'classes' => array('class'),
  );
  $items['validator'] = array(
    'cache' => FALSE,
    'classes' => array('class'),
  );

  return $items;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function render_cache_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'render_cache') {
    return 'plugins/render_cache/' . $plugin_type;
  }
}

// -----------------------------------------------------------------------
// Public API

/**
 * Returns a render cache controller.
 */
function render_cache_get_controller($type) {
  return render_cache_get_plugin_handler('controller', $type);
}

/**
 * Returns a render cache validation strategy plugin.
 */
function render_cache_get_validator($type) {
  return render_cache_get_plugin_handler('validator', $type);
}

/**
 * Invokes attached post-render callbacks.
 *
 * This function can not be named "render_cache_post_render" because that is
 * the name of the #attached element.  Any function with the name of an
 * #attached element will be invoked to process it from
 * drupal_process_attached().
 *
 * @param &$element Array
 *    The renderable element to check for and run post-render callbacks on.
 * @param $id String
 *    An identifier for this render-cacheable elements.
 */
function render_cache_process_attached_callbacks(&$element, $id) {
  if (isset($element['#markup']) && !empty($element['#attached']['render_cache_post_render'])) {
    foreach ($element['#attached']['render_cache_post_render'] as $function) {
      // Fail fatally if the function has not been defined.
      $element['#markup'] = call_user_func($function, $element['#markup'], $id);
    }
    unset($element['#attached']['render_cache_post_render']);
  }
}

/**
 * Check if this call should / can be served from the cache.
 *
 * By default only GET and / or HEAD requests are cacheable.
 *
 * @param bool $allow_caching
 *   Set to FALSE if you want to prevent this call to get the cached version and
 *   / or fill the cache.
  * @param bool $ignore_request_method_check
 *   Set to TRUE if you want to ignore the request method check.
 *
 * @return bool
 *   TRUE if the current call can be cached, FALSE otherwise.
 *
 * @see drupal_page_is_cacheable()
 */
function render_cache_call_is_cacheable($allow_caching = NULL, $ignore_request_method_check = FALSE) {
  $allow_caching_static = &drupal_static(__FUNCTION__, TRUE);
  if (isset($allow_caching)) {
    $allow_caching_static = $allow_caching;
  }

  return $allow_caching_static
    && ($ignore_request_method_check
      || ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD'))
    && !drupal_is_cli();
}

// -----------------------------------------------------------------------
// Helper functions

/**
 * Fetch the correct plugin for type with the given plugin_type.
 *
 * @param string $type
 * @param string $plugin_type
 * @return array
 *   A CTools plugin array.
 */
function render_cache_get_plugin($plugin_type, $type) {
  ctools_include('plugins');
  return ctools_get_plugins('render_cache', $plugin_type, $type);
}

/**
 * Fetch all RenderCache plugins of the given plugin type.
 *
 * @return array
 *   An array of RenderCache plugin arrays.
 */
function render_cache_get_plugins($plugin_type) {
  ctools_include('plugins');
  return ctools_get_plugins('render_cache', $plugin_type);
}

/**
 * Returns a render cache plugin for the given type and plugin_type.
 *
 * If a plugin does not define a class at all, then the default class.
 *
 * @param string $plugin_type
 *   The plugin type to load, 'controller' or 'validator' are valid.
 * @param string $type
 *   The type of plugin to load.
 *
 * @return RenderCacheControllerInterface or RenderCacheValidationStrategyInterface
 *   Either the instantiated handler or FALSE if one could not be had.
 */
function render_cache_get_plugin_handler($plugin_type, $type) {
  $full_cache = &drupal_static(__FUNCTION__, array());
  $full_cache += array(
    $plugin_type => array(),
  );
  $cache = &$full_cache[$plugin_type];

  $plugin = render_cache_get_plugin($plugin_type, $type);
  if (!$plugin) {
    return FALSE;
  }

  // Get the class name from the 'class' property if we have not already
  // cached a handler.
  if (empty($cache[$plugin['name']]) && ($class = ctools_plugin_get_class($plugin, 'class'))) {
    $cache[$plugin['name']] = new $class($plugin);
  }
  return !empty($cache[$plugin['name']]) ? $cache[$plugin['name']] : FALSE;
}
